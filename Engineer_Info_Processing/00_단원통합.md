# 1. 요구사항 확인
## 1. 소프트웨어 개발방법론
### 소프트웨어 생명주기 모델
- 시스템의 요구분석부터 유지보수까지 **전 공정을 체계화한 절차**
- 시스템이 개발될 때부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화한 것


### 소프트웨어 생명주기 모델의 단계
#### 1. 요구사항 분석
- 다양한 이해관계자의 상충할 수도 있는 요구사항을 고려하여 **새로운 제품이나 변경된 제품에 부합하는 요구와 조건을 결정**하는 단계
#### 2. 설계
- 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 **수행 방법을 논리적으로 결정**하는 단계
#### 3. 구현
- 설계 단계에서 논리적으로 결정한 문제 해결 방법을 특정 프로그래밍 언어를 사용하여 **실제 프로그램을 작성**하는 단계
#### 4. 테스트
- 시스템이 정해진 요구를 만족하는지, 예상과 살제 결과가 어떤 차이를 보이는지 **검사하고 평가**하는 단계
#### 5. 유지보수
- 시스템이 인수되고 설치된 후 일어나는 모든 활동



### 방법론의 종류
#### 1. 구조적 방법론
- 전체 시스템을 **기능에 따라 나누어 개발**하고, 이를 통합하는 **분할과 정복** 접근 방식의 방법론
#### 2. 정보공학 방법론
- 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
- **개발주기를 이용**해 대형 프로젝트를 수행하는 체계적인 방법론
#### 3. 객체지향 방법론
- **객체**라는 기본 단위로 시스템을 분석 및 설계하는 방법론 
- 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론
#### 4. 컴포넌트 기반 방법론(CBD)
- 소프트웨어를 구성하는 **컴포넌트를 조립**해서 하나의 새로운 응용 프로그램을 작성하는 방법론
#### 5. 애자일 방법론
- 절차보다는 **사람이 중심**이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
- 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
#### 6. 제품 계열 방법론
- 특정 제품에 적용하고 싶은 **공통된 기능을 정의하여 개발**하는 방법론
- **임베디드 소프트웨어**를 작성하는 데 유용한 방법론

### XP의 12가지 가치
#### 1. 짝 프로그래밍
- 개발자 둘이서 **짝으로 코딩**하는 원리
#### 2. 지속적인 통합
- 매일 여러 번씩 소프트웨어를 **통합하고 빌드**해야 한다는 원리
#### 3. 메타포어
- **공통적인 이름 체계와 시스템 서술서**를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원리
#### 4. 테스트 기반 개발(TDD)
- 작성해야 하는 프로그램에 대한 **테스트를 먼저 수행**하고, 이 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리
#### 5. 리팩토링
- 프로그램의 **기능을 바꾸지 않으면서** 중복제거, 단순화 등을 위해 **시스템 재구성**을 한다는 원리


이외에도 *공동 코드 소유, 계획 세우기, 작은 릴리즈, 간단한 디자인, 40시간 작업, 고객 상주, 코드 표준*이 있다.


### 델파이 기법
- 전문가의 **경험적 지식**을 통한 문제 해결 및 미래예측을 위한 기법으로 전문가 합의법이라고도 한다.


### 비용 산정 방식의 종류
#### 1. LoC
- 소트트웨어 각 기능의 **원시 코드 라인 수의 낙관치, 중간치, 비관치**를 측정하여 예측치를 구하고 이를 응용하여 비용을 산정하는 방식
#### 2. Man Month
- 한 사람이 **1개월동안 할 수 있는 일의 양**을 기준으로 프로젝트 비용을 산정하는 방식
#### 3. COCOMO
- **보헴이 제안한 모형**으로 프로그램 규모에 따라 비용을 산정하는 방식
#### 4. 푸트남(Putnam)
- 소프트웨어 개발주기의 **단계별로 요구할 인력의 분포**를 가정하는 방식
#### 5. 기능점수(FP)
- 요구 기능을 증가시키는 인자별로 **가중치를 부여**하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

### 일정 관리 기법의 종류
#### 1. 주 공정법(CPM)
- 여러 작업들의 **수행 순서가 얽혀 있는 프로젝트**의 일정을 계산하는 방법

#### 2. PERT
- 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 **비관치, 중간치, 낙관치**의 3점 추정방식을 통해 일정을 관리하는 기법

#### 3. 중요 연쇄 프로젝트 관리(CCPM)
- 주 공정 연소법으로 자원제약사항을 고려하여 일정을 작성하는 기법


## 2. 현행 시스템 분석
### 디자인 패턴
- 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
- 이를 참고하여 개발할 경우 개발의 효율성, 유지보수성, 운용성이 높아지며 최적화에 도움이 된다.
- 디자인 패턴에는 크게 **생성, 구조, 행위 패턴**이 존재한다.

### 디자인 패턴-생성 패턴
#### 1. Builder
- 복잡한 인스턴스를 조립하여 만드는 구조
- 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로 동일한 생성절차에서 서로 다른 표현 결과를 만들 수 있는 패턴
- 작게 분리된 인스턴스를 **조합하여 새로운 객체를 생성**하는 방법(**조립공장을 생각해보자**)

#### 2. Prototype
- 처음부터 일반적인 원형을 만들어놓고, **그것을 복사(복제)**한 후 필요한 부분만 수정하여 사용하는 패턴(원형 복제품을 생각해보자)
- 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정함
- 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴

#### 3. Factory Method
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 만드는 방식
- 객체의 **생성을 서브클래스에서** 하도록 하는 구조(가상 생성자 이용. 공장을 생각해보자)

#### 4. Abstract Factory
- 구체적인 클래스에 의존하지 않고 **서로 연관되거나 의존적인 객체들의 조합**을 만드는 인터페이스를 제공하는 패턴
- **추상적인 표현**만을 하여 구체적인 표현은 Concrete Product 클래스에서 이루어지도록 함(자기 할 일만 하는 조립공장을 생각해보자)

#### 5. Singleton
- 전역 변수를 사용하지 않고 객체를 **하나만 생성**하도록 하며, 생성된 객체를 **어디에서든지 참조**할 수 있도록 하는 패턴
- 여러 프로세스가 동시에 참조할 수는 없다(정수기를 생각해보자)

### 디자인 패턴-구조 패턴
#### 1. Bridge
- 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
- 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 사용한다.
- **추상층을 분리하여 서로가 독립적으로 확장함**(따로따로 지어지는 다리를 생각해보자)

#### 2. Facade
- 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로 사용자와 시스템 간, 또는 여타 시스템과의 **결합도를 낮추어** 시스템 구조에 대한 파악을 쉽게 하는 패턴
- 오류에 대해 단위별로 확인할 수 있으며, 사용자 측면에서 단순한 인터페이스 제공으로 접근성을 높일 수 있다는 특징을 가짐
- **상위 인터페이스 구성으로 서브 클래스의 기능을 사용**할 수 있는 패턴(TV를 조종할 수 있는 리모컨을 생각하자)

#### 3. Adapter
- 기존 생성된 클래스를 재사용할 수 있도록 **중간에서 맞춰주는 역할을 하는 인터페이스**를 만드는 패턴
- 상속을 이용하는 클래스 패턴, 위임을 이용하는 인스턴스 패턴 두 가지 형태로 이용됨
- 타 클래스의 인터페이스를 기존 인터페이스에 덮어 씌우기도 함(변압기를 생각하자)

### 디자인 패턴-행위 패턴
#### 1. Template Method
- 어떤 작업을 처리하는 일부분을 **서브 클래스로 캡슐화**해 전체 일을 수행하는 구조는 바꾸지 않는 패턴
- **상위 클래스는 추상 클래스, 하위 클래스에 세부 내용**을 처리함으로 코드 양을 줄일고 유지보수를 용이하게 함
#### 2. Command
- **실행될 기능을 캡슐화**함으로 주어진 여러 기능을 수행할 수 있는 재사용성이 높은 클래스 설계 패턴
- **하나의 추상 클래스에 여러 메소드**가 있어 한 명령에 따라 그에 맞는 서브 클래스가 선택됨
- 재이용/취소가 가능하도록 로그가 남는다는 특징을 가진다.

#### 3. Observer
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 **다른 객체들한테 연락**이 가고 자동으로 내용이 갱신되는 패턴
- 일대 다의 의존성을 가지며 상호작용하는 객체 사이에서는 가능하면 **느슨한 결합**을 유지한다.

#### 4. State
- **객체 상태를 캡슐화**하여 클래스화함으로 그것을 참조하게 하는 방식
- 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여 원시 코드의 수정을 최소화할 수 있다.

#### 5. Strategy
- 알고리즘군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, **필요할 때 서로 교환**해서 사용할 수 있게 하는 패턴
- 동일  계열 알고리즘을 개별적으로 캡슐화하는 기법

#### 6. Visitor
- 처리 기능을 분리하고 각 클래스를 **방문하여 수행**하는 방식



### Android
- 구글에서 개발한 운영체제. **리눅스 위에서 구동**한다.
- 휴대전화를 비롯한 휴대용 장치를 위한 운영체제, 미들웨어, 사용자 인터페이스, 표준 응용 프로그램 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제이다.
- 개발자들이 **자바와 코틀린 언어**로 응용 프로그램을 작성할 수 있게 했고, 컴파일된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영체제임.

### 소프트웨어 아키텍처
-  여러가지 소프트웨어 구성요소와 그 구성요소가 가지는 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체


### 4+1 뷰의 종류
#### 1. 유스케이스 뷰
- 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰
- 사용자, 설계자, 개발자, 테스트 관점에서 존재
#### 2. 논리 뷰
- 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
- 설계자, 개발자 관점

#### 3. 프로세스 뷰
- 시스템의 비기능적인 속성
- 자원의 효율적 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
- 개발자, 시스템 통합자 관점

#### 4. 구현 뷰
- 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
- 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의

#### 5. 배포 뷰
- 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰


### 아키텍처 패턴의 종류
#### 1. 계층화 패턴(레이어 패턴)
- 시스템을 계층으로 구분하여 구성하는 패턴
- 각각의 서브시스템이 계층구조를 이루는 고전적 패턴

#### 2. 클라이언트-서버 패턴

 - 하나의 서버와 다수의 클라이언트로 구성된 패턴
 - 서버는 상시 대기 상태이며, 상호간 응답을 위한 동기화를 제외하면 서로 독립적이다

#### 3. 파이프-필터 패턴
- 데이터 스트림을 생성하고 처리하는 시스템에서 사용가능한 패턴
- 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송한다.

#### 4. 모델-뷰-컨트롤러(MVC) 패턴
- 대화형 어플리케이션을 모델, 뷰, 컨트롤러 3개의 서브시스템으로 구조화하는 패턴
- 모델 : 데이터 보관(핵심기능) / 뷰 : 사용자에게 정보 표시 / 컨트롤러 : 사용자의 입력 처리


이외에도 *마스터-슬레이브 패턴, 브로커 패턴, 피어-투-피어 패턴, 이벤트 버스 패턴(이벤트 메시지를 발행하고 구독하는 형태), 블랙보드 패턴, 인터프리터 패턴* 등이 있다.

## 3. 요구사항 확인
### 요구공학이란
- 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동

### 요구사항의 종류
#### 기능 요구사항
- 목표시스템이 반드시 수행하여야 하거나 목표시스템을 이용하여 사용자가 반드시 수행할 수 있어야 하는 기능
- 분석, 설계, 구현, 테스트 공정을 거쳐 개발하는 요구사항

#### 비기능 요구사항
- 기능 요구사항을 제외한 **성능**, 시스템 장비 구성 요구사항, 인터페이스 요구사항, 데이터 요구사항 등 **생산성에 영향**을 미치는 요인들

### 요구사항 개발 프로세스
#### 1. 요구사항 도출
- 소프트웨어가 해결해야 할 문제를 이해하고 고객으로부터 제시되는 추상적 요구에 대해 관련 정보를 식별
- 수집 방법 결정, 수집된 요구사항을 구체적으로 표현하는 단계

#### 2. 요구사항 분석
- 도출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확인하는 단계

#### 3. 요구사항 명세
- 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성하는 단계

#### 4. 요구사항 확인 및 검증
- 분석가가 요구사항을 이해했는지 확인하고, 요구사항 문서가 회사 표준에 적합한지, 일관성있게 완전한지 검증하는 단계

### 요구사항 명세의 종류
#### 비정형 명세기법
- 사용자의 요구를 표현할 때 **자연어**를 기반으로 서술하는 기법

#### 정형 명세기법
- 사용자의 요구를 표현할 때 **수학적 원리와 전용 표기법**으로 서술하는 기법

소프트웨어의 요구사항을 분석하고 정의하는 단계에서 작성되는 최종 산출물은 **요구사항 명세서**이다.

### 요구사항 검증 방법
#### 1. 관리 리뷰
- 프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰

#### 2. 기술 리뷰
- 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰

#### 3. 인스펙션
- 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 **다른 전문가/팀이 검사**하여 문제를 식별하고 올바른 해결을 찾아내는 형식적인 기법
- 작성자를 제외한 모든 검토 전문가들이 확인한다는 특징을 가짐

#### 4. 워크스루
- **검토 자료(명세서)를 회의 전에 배포**하여 사전 검토한 후 짧은 시간동안 회의를 진행하는 형태
- 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 검토 방법

#### 5. 감사
- 소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고 있는지를 독립적으로 평가하는 방법

# 2. 화면 설계
## 1. UI 요구사항 확인
### UI 설계 원칙 4가지
#### 1. 직관성
- 누구나 쉽게 이해하고 사용할 수 있어야 한다.

#### 2. 학습성
- 누구나 쉽게 배우고 익힐 수 있어야 한다.

#### 3. 유연성
- 사용자의 요구사항을 최대한 수용하며 오류를 최소화해야 한다.

#### 4. 유효성
- 사용자의 목적을 정확하게 달성하여야 한다.

### OUI(Organic User Interface)
-  유기적 상호작용 기반 인터페이스
-  입력장치가 곧 출력장치가 되고 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스

### UI 설계 도구의 종류
#### 1. 와이어프레임
- 페이지에 대한 개략적인 레이아웃/UI 등에 대한 뼈대를 설계함
- 이해관계자들과의 화면구성을 협의, 서비스에 대한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 방시 

#### 2. 목업
- 와이어프레임보다 좀 더 실제와 유사하게 만든 정적 모델

#### 3. 스토리보드
- 와이어프레임 콘텐츠를 설명하는 모형
- 페이지 간 이동 흐름 설명을 추가한 형태임

#### 4. 프로토타입
- 실제 구현된 것처럼 테스트가 가능한 동적 모형

#### 5. 유스케이스
- 사용자 측면의 요구사항이 추가된 모형
- 원하는 목표를 달성하기 위해 수행 내용이 추가 기술되어 있다.


UI 품질 요구사항은 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성이 있다.
### 사용성의 부특성 3가지
#### 1. 이해성
- 소프트웨어의 논리적인 개념과 적용 가능성을 분간하는 데 필요한 사용자의 노력 정도에 따른 소프트웨어 특성

#### 2. 학습성
- 소프트웨어 애플리케이션을 익히는 데 필요한 사용자의 노력 정도에 따른 특성

#### 3. 운용성
- 소프트웨어의 활용과 운용 통제에 필요한 사용자의 노력 정도에 따른 특성


아래는 **ISO/IEC 9126에서 제시한 SW 주요 품질 특성과 그 부특성**
### 1. 기능성
#### 적절/적합성, 정밀/정확성, 상호 운용성, 보안성, 준수성
### 2. 신뢰성
#### 성숙성, 고장허용성, 회복성

## 2. UI 설계
### 패키지 다이어그램
- 폴더 모양의 패키지와 점선으로 표시된 의존관계, import라는 스테리오 타입 표기를 통해 패키지 다이어그램임을 파악할 수 있다.
- 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램으로 패키지와 의존과계로 표현한다

### 양식의 종류
#### 1. Radio Box
- 주어진 항목 중에서 오직 하나만을 선택할 수 있는 컴포넌트

#### 2. Combo Box
- 사용자가 박스를 클릭하면 선택할 항목들이 나타나는 드롭다운 형식의 컴포넌트

#### 3. Check Box
- 주어진 항목 중에서 여러 항목을 선택할 수 있는 사각형 컴포넌트


### UML 다이어그램 관계의 종류
#### 1. 연관관계
- 2개 이상의 사물이 서로 관련되어 있음. 방향성이 존재한다면 실선 화살표로 표시한다.
- ex : 사람은 집을 가지고 있다. 이는 집은 누가 자신을 소유하는지 모른다는 의미이기도 함

#### 2. 집합관계
- 하나의 사물이 다른 사물에 포함되어 있음을 표기. 실선+말단에 비어있는 마름모로 이를 표시한다.
- ex : 컴퓨터에 연결되어 있는 프린터는 포함되어 있지만 서로 독립적인 관계이다. 

#### 3. 포함관계
- 포함하는 사물의 변화가 포함되는 사물에게 영향을 미침. 실선+말단에 채워져 있는 마름모로 이를 표시함
- ex : 문과 그 문의 키는 생명주기를 같이하기 때문에 포함관계에 있다.

#### 4. 일반화 관계
- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현. 실선+말단 비어있는 삼각형으로 이를 표시함
- ex : 아메리카노와 에스프레소는 커피라고도 불릴 수 있기에 일반화 관계이다.

#### 5. 의존 관계
- 사물 사이에 연관은 있으나 서로에게 영향을 주는 짧은 시간동안만 유지. 점선 화살표를 이를 표시함
- ex : 고객 등급에 대한 할인율을 각각 다르고, 등급은 변동성이 강하기에 의존관계라 할 수 있다.

#### 6. 실체화 관계
- 사물이 하거나 할 수 있는 행위를 서로 그룹화할 수 있는 관계. 점선+말단 비어있는 삼각형으로 이를 표시함
- ex : 비행기와 새는 모두 날 수 있는 특성을 가지고 있기에 실체화 관계라 할 수 있다.


### 행위 다이어그램의 종류(동적 다이어그램)
#### 1. 유스케이스 다이어그램
- 사용자 요구 분석. 기능 모델링 작업에 사용하는 다이어그램

#### 2. 시퀀스 다이어그램
- 상호 작용하는 시스템/객체들의 메시지를 표현하기 위해 사용하는 다이어그램

#### 3. 커뮤니케이션 다이어그램
- 동작이 참여하는 객체 메시지와 연관까지 포함하는 다이어그램
- 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현하는 다이어그램

#### 4. 상태 다이어그램
- 한 객체가 자신 클래스의 상태를 변화/상호작용에 따라 변화의 정도를 표현한 다이어그램
- 럼바우 객체지향 분석 기법에서 동적 모델링에서 사용되는 다이어그램

#### 5. 활동 다이어그램

### UML 구성요소 3가지
#### 1. 사물
- 추상적인 개념으로 주제를 나타내는 요소
- 단어 관점에서 '명사' 또는 '동사'를 의미

#### 2. 관계
- 사물의 의미를 확장하고 명확히 하는 요소
- 사물과 사물을 연결하는 요소
- 단어 관점에서 '형용사' 또는 '부사'를 의미

#### 3. 다이어그램
- 사물과 관계를 모아 글미으로 표현한 형태
- 형식과 목적에 따라 다양하게 정의

# 3. 데이터 입출력 구현
## 1. 논리 데이터 저장소 확인
### 관계 대수의 종류
#### 1. 셀렉트(Select)
- 연산자 : $\sigma$
- 릴레이션 R에서 조건을 만족하는 튜플 반환

#### 2. 프로젝트(Project)
- 연산자 : $\pi$
- 릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플 반환

#### 3. 조인(Join)
- 연산자 : 리본?
- 공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어진 튜플 반환

#### 4. 디비전(Division)
- 연산자 : 나누기
- 릴레이션 S의 모든 튜플과 관련있는 R의 튜플 반화 


### 데이터베이스 이상
- 데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상
- 삽입 이상, 삭제 이상, 갱신 이상이 존재함


### 정규화(Normalization)
- 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정
- 함수적 종속성을 이용해서 연관성있는 속성들을 분류하고, 각 릴레이션의 이상 현상이 생기지 않도록 하는 과정
- 잘못 설계된 관계형 스키마를 작은 속성의 세트로 쪼개어 바람직하게 만드는 것


### 비정규화(De-Normalization) = 반정규화
- 정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
- 높은 규모 확장성을 위해 사용되며, 자주 사용되는 Join의 반복을 줄일 수 있다. 
- 의도적으로 정규화 원칙을 위배하는 행위

### 논리 데이터 모델링의 속성
#### 개체, 속성, 관계

### 개체-관계 모델(ER Model)
- 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델
- 요구사항으로부터 얻어낸 정보들을 개체, 속성, 관계로 기술한 모델
- 개체 : 사각형 / 관계 : 마름모 / 속성 : 타원

## 2. 물리 데이터 저장소 설계
### 물리 데이터 모델링
- 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정

### 인덱스 컬럼 선정 기준
- **분포도**가 좋은 컬럼은 단독적으로 생산한다.
- 자주 조합되어 사용되는 컬럼은 **결합 인덱스**로 생성한다.

### *파티셔닝 기법의 종류*
#### 1. 레인지 파티셔닝
- 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝
- 손쉬운 관리 기법을 제공하여 관리 시간의 단축이 가능

#### 2. 해시 파티셔닝
- 파티션 키의 해시 함수 값에 의한 파티셔닝 기법
- 균등한 데이터 분할이 가능하고 질적 향상을 불러오 

#### 3. 리스트 파티셔닝
- 특정 파티션에 저장될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법
- 분포도가 비슷하고 데이터가 많은 SQL에서 컬럼의 조건이 많이 들어오는 경우 유용

#### 4. 컴포지트 파티셔닝
- 범위분할 이후 해시 함수를 적용하여 재분할하는 파티셔닝 기법
- 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분할할 수 있음

### 데이터 모델에 표시할 요소
#### 구조(Structure)
- 논리적으로 표현된 개체/타입 간 관계

#### 연산(Operation)
- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세

#### 제약조건(Constraint)
- 데이터베이스에 저장될 수 있는 실제 데이터의 논리적 제약조건


## 3. 데이터베이스 기초 활용하기
### DBMS
- 데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 검색, 변경 등의 기능을 지원하는 소프트웨어
### 데이터 마이닝
- 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술


### 계층형 데이터베이스(HDBMS)
- 데이터를 상하 종속적인 관계로 계층화하여 관리하는 데이터베이스
- 데이터에 대한 접근속도가 빠르지만, 종속적인 구조로 변화하는 데이터 구조에 유연한 대처가 어려움
- IMS, System2000 등이 존재


### DBMS 특징
#### 1. 데이터 무결성
- 부적절한 자료가 입력되어 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는 성질

#### 2. 데이터 일관성
- 삽입, 삭제, 갱신, 생성 후에도 저장된 데이터가 변함없이 일정

#### 3. 데이터 회복성
- 장애가 발생하였을 때 특정 상태로 복구되어야 하는 성질

#### 4. 데이터 보안성
- 불법적인 노출, 변경, 손실로부터 보호되어야 하는 성질

#### 5. 데이터 효율성
- 응답 시간, 저장 공간 활용 등이 최적화되어 사용자, 소프트웨어, 시스템 등의 요구조건을 만족시켜야 하는 성질

### ERD(Entity-Relation Diagram)
- 업무 분석 결과도 도출된 실체(개체)와 개체 간의 관계를 도식화한 다이어그램
- 개체-관계 모델에서의 최종 산출물이 ERD이기도 하다.


### 온톨로지(Ontology)
- 실세계에 존재한느 모든 개념과 개념들의 속성, 그리고 개념간의 관계 정보를 컴퓨터가 이해할 수 있도록 서술해 놓은 지식베이스

### 데이터베이스 정의
#### 1. 통합된 데이터(Integrated Data)
- 자료의 중복을 배제한 데이터의 모임

#### 2. 저장된 데이터(Stored Data)
- 저장 매체에 저장된 데이터

#### 3. 운영 데이터(Operational Data)
- 조직의 업무를 수행하는 데 필요한 데이터

#### 4. 공용 데이터(Shared Data)
- 여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터

### 데이터베이스의 특성
#### 1. 실시간 접근성(Real-Time Accessibillity)
- 쿼리에 대하여 실시간 응답이 가능해야 함

#### 2. 계속적인 변화(Continuous Evolution)
- 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지함

#### 3. 동시 공용(Concurrent Sharing)
- 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함

#### 4. 내용 참조(Content Reference)
- 데이터베이스에 있는 데이터를 참조할 때 사용자가 요구하는 데이터 내용으로 데이터를 찾아야 함

# 4. 통합 구현
## 1. 연계 데이터 구성
### 요구사항 분석 기법
#### 인터뷰
- 사용자 면담을 통해 연계 요구사항을 분석하는 기법

#### 체크리스트
- 시스템 운영 환경, 성능, 보안, 데이터 발생 주기 등의 기준에 대한 점검을 통한 분석기법

#### 브레인스토밍
- 소속된 인원들이 자발적으로 자연스럽게 제시된 아이디어 목록을 통해 연계 요구사항을 분석하는 기법

### 연계 시스템의 구성
#### 송신 시스템
- 연계할 데이터를 데이터베이스와 애플리케이션으로부터 연계 테이블 또는 파일 형태로 생성하여 송신하는 시스템

#### 수신 시스템
- 수신한 연계 테이블 또는 파일의 데이터를 수신 시스템에서 관리하는 데이터 형식에 맞게 변환하여 데이터베이스에 저장하거나 애플리케이션에서 활용할 수 있도록 제공하는 시스템

#### 중계 서버(중계 시스템)
- 송신 시스템과 수신 시스템 사이에서 데이터를 송수신하고 연계 데이터의 송수신 현황을 모니터링하는 시스템


## 2. 연계 메커니즘 구성
### 연계 방식의 분류
#### 직접 연계
**장점**
- 연계 및 통합 구현이 단순하며 용이함
- 개발 소요 비용 및 기간이 짧음
- 중간 매개체가 없으므로 데이터 연계 처리 성능이 대체로 좋음

**단점**
- 시스템간의 결합도가 높아 시스템 변경에 민감
- 암/복호화 처리 불가
- 연계 및 통합 가능한 시스템 환경이 제한적

#### 간접 연계
**장점**
- 서로 상이한 네트워크, 프로토콜 연계 및 통합 가능
- 인터페이스 변경 외에도 장애나 오류 없이 서비스 가능
- 보안이나 업무 처리 로직을 자유롭게 반영 가능

**단점**
- 연계 아키텍처 및 메커니즘이 복잡해 성능 저하 요소 존재
- 개발 및 적용을 위한 테스트 기간이 상대적 장기간 소요

### 주요 연계 기술-직접 연계
#### DB 링크(DB Link)
- 데이터베이스에서 제공하는 DB 링크 객체를 이용
- 수신 시스템에서 DB  링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식

#### DB 연결(DB Connection)
- 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 **DB Connection Pool**을 생성하고, 연계 프로그램에서 해당 DB 커넥션 풀을 이용하여 전달

#### API/Open API
- 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
- API 명, 입출력 파라미터 정보기가 필요함

#### JDBC 
- 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
- DBMS 유형, DBMS 서버 IP와 Port, DB 인스턴스 정보가 필요

#### 하이퍼링크
- 현재 페이지에서 다른 부분으로 가거나 전혀 다른 페이지로 이동하게 해주는 속성

### 주요 연계 기술-간접 연계
#### 연계 솔루션(EAI)
- 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션
- 송수신 시스템에 설치되는 어댑터 이용

#### Web-Service/ESB
- 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간의 연계

#### 소켓(Socket)
- 소켓을 생성하여 포트를 할당하고, 클라이언트 요청을 연결하여 통신

## 3. 내외부 연계 모듈 구현
### EAI(Enterprise Application Integration)
- 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션
- 각 비즈니스 간 통합 및 연계성을 증대시켜 효율성을 높여줄 수 있으며, 시스템 간 확장을 높여줄 수 있음

### ESB(Enterprise Service Bus)
- 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처
- **미들웨어 중심**으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 통합을 **느슨한 결합** 방식으로 지원하는 방식
### EAI 구축 유형
#### 1. 포인트 투 포인트(Point-to-Point)
- 가장 기초적인 애플리케이션 통합방법으로 1:1 단순 통합방법
- 솔루션을 구매하지 않고 개발자 간의 커뮤니케이션을 통해서도 통합 가능

#### 2. 허브 앤 스포크(Hub & Spoke)
- 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식
- 허브 장애 시 전체 장애 발생

#### 3. 메시지 버스
- 애플리케이션 사이 미들웨어(버스)를 두어 연계하는 미들웨어 통합 방식
- 뛰어난 확장성과 대용량 데이터 처리 가능

#### 4. 하이브리드
- 그룹 내는 허브 앤 스포크 방식, 그룹 간에는 메시지 버스 방식을 사용하는 통합 방식
- 그룹 내 환경에 맞는 작업이 가능해짐

### 웹 서비스
- 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술
- 서비스 지향 아키텍처 개념을 실현하는 대표적인 기술

### EAI 구성요소
#### 1. EAI 플랫폼(EAI Platform)
- 이기종 시스템 간 애플리케이션 상호 운영
- 데이터의 신뢰성있는 전송을 위한 메시지 큐와 트랜잭션 미들웨어 기능 수행
- 대규모 사용자 환경 지원을 위한 유연성과 확장성 보장

#### 2. 어댑터(Adapter)
- 다양한 패키지 애플리케이션 및 기업에서 자체적으로 개발한 **애플리케이션을 연결하는 EAI의 핵심 장치**로 데이터 입출력 도구

#### 3. 브로커(Broker)
- 시스템 상호 간 데이터가 전송될 때 데이터 포맷과 코드를 변환하는 솔루션

#### 4. 메시지 큐(Message Queue)
- 비동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터를 송수신하는 기술

#### 5. 비즈니스 워크플로우(Business Workflow)
- 미리 정의된 기업의 비즈니스 Workflow에 따라 업무를 처리하는 기술

### 웹 서비스 유형
#### 1 SOAP(Simple Object Access Protocol)
- HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜
- HTTP 프로토콜 상에 SOAP Envelope, 헤더, 바디 등이 추가된 XML 문서로 기본적인 송수신은 HTTP로 수행
- SOAP 대신 레스트 풀(RESTful) 프로토콜로 대체가 가능함

#### 2. WSDL(Web Service Description Language)
- 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구현된 언어
- SOAP와 XML 스키마와 결합하여 인터넷 상에 웹 서비스를 제공하기 위해 사용되기도 함

#### 3. UDDI(Universal Description, Discovery and Integration)
- 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소
- 공개적으로 접근, 검색이 가능한 레지스트리이자 표준
- 서비스 제공자는 UDDI라는 서비스 소비자에게 이미 알려진 온라인 저장소에 그들이 제공하는 서비스 목록들을 저장하게 되고, 서비스 소비자들은 그 저장소에 접근함으로써 원하는 서비스들의 목록을 찾을 수 있게 된다.

### REST
- HTTP URI를 통해 자원을 명시하고, HTTP 메서드(POST, DELETE, GET, PUT)를 통해 해당 자원에 대한 생성, 조회, 갱신, 삭제 등의 명령을 적용할 수 있는 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처

# 5. 인터페이스 구현
## 1. 인터페이스 설계 확인
### 인터페이스 설계서
- 이기종 시스템 및 컴포넌트 간 데이터 교환 및 처리를 위해 각 시스템의 교환되는 데이터, 업무, 송수신 주체 등이 정의된 문서
- 시스템의 인터페이스 현황 파악을 위해서 인터페이스 목록 및 각 인터페이스의 상세 데이터 명세, 각 기능의 세부 인터페이스 정보를 정의한 문서

시스템 인터페이스 설계서는 시스템 인터페이스 목록과 시스템 인터페이스 정의서(인터페이스 id별 별개 정의서)로 구성된다.

### 인터페이스 데이터 표준 확인 절차
#### 1. 데이터 인터페이스 입/출력 의미 파악
- 식별된 데이터 인터페이스의 입력값, 출력값이 의미하는 내용을 파악하고, 각 출력값이 의미하는 바와 데이터의 특성 등 참고할 만한 사항을 구체적으로 작성 

#### 2. 데이터 인터페이스 입/출력 의미 파악을 통한 데이터 표준 확인
- 데이터 인터페이스의 각 항목의 의미 분석 후, 이를 기반으로 데이터 표준 확인

#### 3. 인터페이스 데이터 항목 식별
- 식별된 인터페이스 기능을 통해 인터페이스 데이터 항목을 식별

#### 4. 데이터 표준 최종 확인
- 식별된 인터페이스 기능 및 데이터 항목을 통해 필요한 데이터 표준 및 조정해야 할 항목을 검토 및 확인
- 송/수신 시스템 간 인터페이스 데이터 표준을 최종적으로 확인

## 2. 인터페이스 기능 구현
### 인터페이스 기능 구현 기술
#### 1. JSON(Javascript Object Notation)
- 속성-값(Attribute-Value Pair) 쌍 또는 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
- AJAX에서 많이 사용되고, XML을 대체하는 주요 데이터 포맷
- 언어 독립형 데이터 포맷으로 다양한 데이터 프로그래밍 언어에서 사용됨
- 사람이 읽고 쓰기 용이하며, 기계가 분석하고 생성하기 용이함

#### 2. XML(Extensible Markup Language)
- HTML의 단점을 보완한 인터넷 언어로, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
- 송/수신 시스템 간 데이터 연계의 편의성을 위해서 전송되는 데이터 구조를 동일한 형태로 정의
- 인간과 기계가 모두 이해할 수 있는 텍스트 형태로 마크업 포맷을 정의하기 위한 메타언어

#### 4. AJAX(Asynchronous Javascript And XML)
- 자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술
- 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 로드하지 않고 필요한 일부 페이지의 데이터만을 로드하는 기법
- 하이퍼텍스트 표기 언어(HTML)만으로는 어려운 다양한 작업을 웹 페이지에서 구현해서 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 구현하는 기법

#### 5. REST(Representional State Transfer)
- 웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍처
- 크게 **리소스(자원), 메서드(처리), 메시지** 3가지 요소로 구성된다.

인터페이스 구현 방법에는 **데이터 통신**을 사용하여 인터페이스를 구현하는 방법, 인터페이스 **개체**를 사용하여 인터페이스를 구현하는 방법이 있다.

### 데이터베이스 암호화 알고리즘의 종류
#### 1. 대칭 키 암호화 알고리즘
- 암/복호화에 같은 암호 키를 쓰는 알고리즘
- ARIA 128/192/256, SEED

#### 2. 비대칭 키 암호화 알고리즘
- 공개키는 누구나 알 수 있지만, 그에 대응하는 비밀키는 키의 소유자만이 알 수 있도록 공캐키와 비밀키를 사용하는 알고리즘
- RSA, ECC, ECDSA

#### 3. 해시 암호화 알고리즘
- 해시값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘
- SHA-256/384/512, HAS-160

### 데이터베이스 암호화 기법
#### API 방식
- **애플리케이션 레벨**에서 암호 모듈을 적용하는 애플리케이션 수정 방식
- 애플리케이션 서버에 암/복호화, 정책 관리, 키 관리 등의 부하 발생

#### Plug-in 방식
- 암/복호화 모듈이 **DB 서버**에 설치된 방식
- DB 서버에 암/복호화, 정책 관리, 키 관리 등에 부하 발생

## 3. 인터페이스 구현 검증
### 인터페이스 구현 검증 도구
#### xUnit
- 자바, C++, .Net등 다양한 언어를 지원하는 단위테스트 프레임워크
- 소프트웨어의 함수나 클래스 같은 서로 다른 구성 원소(단위)를 테스트할 수 있게 해주는 도구

#### STAF
- 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합며 자동화하는 검증 도구

#### FitNesse
- 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크
- 사용자가 테스트 케이스 테이블을 작성하면 빠르고 편하게 자동으로 원하는 값에 대해 테스트를 할 수 있는 장점

#### NTAF
- FitNesse의 장점이 협업 기능과 STAF의 재사용/확장성을 통합한 NHN의 테스트 자동화 프레임워크

#### Selenium
- 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크
- 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 만들기 위한 도구를 제공

#### watir
- 루비(Ruby) 기반 웹 애플리케이션 테스트 프레임워크
- 모든 언어 기반의 웹 애플리케이션 테스트와 브라우저 호환성 테스팅 

### 스니핑(Sniffing)
- 공격 대상에게 직접적으로 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격형태

### IPSec(IP Security)
- IP 계층에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용하여 양 종단간 구간에 보안 서비스를 제공하는 터널링 프로토콜
- 동작 모드로 전송(Transfer) 모드와 터널(Tunnel) 모드가 있다.
- 주요 프로토콜로 AH, ESP, IKE(키교환)이 있고, IPSec 정책에는 SPD, SAD가 있다.

# 7. SQL 응용
## 1. 데이터베이스 기본
### 스키마
- 데이터베이스의 구조와 제약조건에 관한 전반적인 명세
### 트랜잭션
- 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 처리하기 위한 **작업의 기본 단위**

### 트랜잭션의 특성
#### 1. 원자성(Atomicity)
- 분해가 불가능한 작업의 최소단위
- 연산 전체가 성공 또는 실패(All or Nothing)
- 하나라도 실패할 경우 전체가 취소되어야 하는 특성

#### 2. 일관성(Consistency)
- 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야하는 특성

#### 3. 격리성(Isolation)
- 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가능한 특성

#### 4. 영속성(Durabillity)
- 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성

### 트랜잭션 제어-TCL 명령어
#### 1. 커밋(COMMIT)
- 트랜잭션을 메모리에 영구적으로 저장하는 명령어

#### 2. 롤백(ROLLBACK)
- 트랜잭션 내역을 저장 무효화시키는 명령어

#### 3. 체크포인트(CHECKPOINT)
- ROLLBACK을 위한 시점을 지정하는 명령어

### 병행 제어 기법의 종류

#### 1. 로킹(Locking)
- 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
- 로킹 단위가 작아지면 데이터베이스 공유도 증가, 하지만 그에따른 오버헤드도 증가
- 한 번에 로킹할 수 있는 단위를 로킹 단위라고 함

#### 2. 타임 스탬프 순서(Time Stamp Ordering)
- 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법

그 외에도 낙관적 검증, 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)이 있다. 

### 회복 기법(영속성 주요 기법)
- 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업

### 회복 기법의 종류-로그 기반 회복 기법
#### 지연갱신 회복기법(Deferred Update)
- 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법

#### 즉각갱신 회복기법(Immediate Update)
- 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법

### 그 외의 회복 기법
#### 체크 포인트 회복기법(Checkpoint Recovery)
- 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법

#### 그림자 페이징 회복기법(Shadow Paging Recovery)
- 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시, 이를 이용하여 복구하는 기법

### DDL(Data Definition Language)
- 데이터 정의어는 데이터를 정의하는 언어로 '데이터를 담는 그릇을 정의하는 언어'임
- 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들을 데이터 정의어라고 부름

### 뷰(View)
- 논리 테이블로 사용자에게 사용 관점에서의 테이블과 동일하다.

### 뷰의 특징
- **논리적 데이터 독립성 제공** :  데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 데이터에 접근 가능
- **데이터 조작 연산 간소화** : 애플리케이션이 원하는 형태의 논리적 구조를 형성하여 데이터 조작 연산을 간소화
- **보안 기능(접근제어)** : 특정 필드만을 선택해 뷰를 생성할 경우 애플리케이션은 선택되지 않은 필드의 조회 및 접근 불가
- **뷰 변경 불가** : 뷰 정의는 ALTER 문을 이용하여 변경할 수 없음(뷰는 CREATE 문을 사용하여 정의, 뷰를 제거할 때에는 DROP문을 사용)

### 1. DDL 명령어
- **CREATE** : 데이터베이스 오브젝트를 생성
- **ALTER** : 데이터베이스 오브젝트를 변경
- **DROP** : 데이터베이스 오브젝트를 삭제
- TRUNCATE :  데이터베이스 오브젝트의 내용을 삭제

### DDL 사용 예시
ex1) **CREATE SCHEMA**  *대학교* **AUTHORIZATION** *홍길동*; 
- 소유권자의 사용자 ID가 '홍길동'인 스키마 '대학교'를 정의

ex2) **CREATE DOMAIN** SEX **CHAR**(1)
- 정의 도메인 이름은 'SEX'이고 문자형임. 문자형의 크기를 1로 지정


**DEFAULT** '남'
- 지정 속성의 기본값을 '남'으로 지정


**CONSTRAINT VALID** -SEX **CHECK(VALUE IN(**'남','여'**))**;
- SEX를 지정한 속성성에는 '남','여' 중 하나밖에 안 됨

ex3) **CREATE TABLE** 학생
- <학생> 테이블 생성


(이름 **VARCHAR(15) NOT NULL**,
- '이름'의 최대 문자 크기는 15, NULL값이 존재하지 않음


학번 **CHAR(8)**,
- '학번' 속성은 문자 8자


전공 **CHAR(5)**,
- '전공' 속성은 문자 5자


성별 SEX,
- '성별' 속성은 'SEX', 도메인을 자료형으로 사용한 형태


생년월일 **DATE**,
- '생년월일' 속성은 DATE 자료형을 갖는다.


**PRIMARY KEY**(학번)
- '학번'을 기본키로 삼는다.


**FOREIGN KEY**(전공) **REFERENCES 학과**(학과코드)
- '전공' 속성은 <학과>테이블의 '학과코드'속성을 참조하는 외래키임


**ON DELETE SET NULL**,
- <학과> 테이블 튜플이 삭제되면 관련 튜플의 모든 '전공' 속성값을 NULL로 함


**ON UPDATE CASCADE**.
- <학과> 테이블 튜플 갱신 시 관련 튜플의 모든 ' 전공' 속성값도 같은 값으로

**CONTRAINT** 생년월일제약
- 제약조건의 이름을 '생년월일제약'으로 지정

**CHECK**(생년월일>='1980-01-01'));
- 1980-01-01 이후의 값만을 저장할 수 있음


#### VIEW의 생성
**CREATE VIEW** 뷰명(속성들)

**AS SELECT**구문 : 뷰와 짝꿍임

**FROM**

**WHERE**

#### INDEX 생성
**CREATE [UNIQUE] INDEX** 인덱스명

**ON** 테이블명(속성명 ASC|DESC) : 인덱스와 짝꿍임

#### ALTER TABLE
추가를 위해서는 **ADD**, 변경을 위해서는 **ALTER**

**ALTER TABLE** 테이블명 **ADD** 속성명 데이터_타입

**ALTER TABLE** 테이블명 **ALTER** 속성명

#### DROP TABLE
제거할 요소를 참조하는 다른 모든 개체를 제거하고 싶은 경우에는 **CASCADE**

다른 개체가 제거할 요소를 참조중일때는 제거를 취소하고 싶은 경우에는 **RESTRICT**


### 2. DCL(Data Control Language)
- 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어
- GRANT, REVOKE, COMMIT, ROLLBACK, SAVEPOINT 등이 존재

#### GRANT/REVOKE
**GRANT [ALL ON]** 사용자등급 **TO** 사용자 : 권한 부여
- **ALL ON** 항목 추가 시 다른사람에게 권한 부여 권한까지 줌

REVOKE 사용자등급 TO 사용자 : 권한 취소

#### COMMIT/ROLLBACK/SAVEPOINT
- 트랜잭션이 성공적으로 완료되었다는 의미로 **COMMIT** 기능 설정
- **SAVEPOINT** 저장 후 **ROLLBACK TO** 명령어로 원하는 **SAVEPOINT**로의 이동이 가능

### 3. DML(Data Manipulation Language)
- 데이터베이스 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 관리하는데 사용되는 언어
#### DML의 종류
- **SELECT** : 테이블에서 튜플을 검색한다.
- **INSERT** : 테이블에 새로운 튜플을 삽입한다.
- **DELETE** : 테이블에서 튜플을 삭제한다.
- **UPDATE** : 테이블에서 튜플의 내용을 검색한다.

### INSERT TO : 삽입문
**INSERT INTO** 테이블명(속성1,속성2,...)

**VALUES** (데이터1,데이터2,...)
- VALUES 대신 SELECT FROM WHERE 구문을 이용한 검색도 가능

### DELETE FROM : 삭제문
**DELETE**

**FROM** 테이블명

**WHERE** 조건

### UPDATE SET : 갱신문
**UPDATE** 테이블명

**SET** 속성명=데이터

**WHERE** 조건

### DML 정리
- **SELECT...FROM...WHERE**
- **INSERT...INTO...VALUES**
- **UPDATE...ON...WHERE**
- **DELETE...FROM....WHERE**

## 2. 응용 SQL 작성하기
#### SELECT 심화
**SELECT**

**WINDOW OVER** (**PARTITION BY** 속성명1, ... **ORDER BY** 속성명 [ASC|DESC]) AS 별칭

FROM...WHERE

#### SELECT 심화 : GROUP BY
**SELECT** 속성명1,..., **그룹함수**(*속성*) 
- ...별 '*속성*'의 평균. *튜플*이라면 그룹함수에 *을 붙인다.

**FROM**  테이블명

**GROUP BY** *속성*
- '**속성**'별 ...의 평균의 '...별' 쪽의 속성 담당


## 3. 절차형 SQL 활용하기
### 프로시저
- 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
- 코딩에서의 함수를 생각하면 편할 듯?


### 사용자 정의함수
- 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL

### 트리거
- 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL


### 옵티마이저(Optimizer)
- SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심엔진
- 사용자가 SQL로 결과를 요구하면 처리경로는 DBMS에 내장된 옵티마이저가 자동으로 생성해준다.

# 8. 서버 프로그램 구현
## 1. 개발환경 구축
### 형상 통제
- 형상 항목의 버전 관리를 위해 변경 여부와 변경 활동을 통제하는 활동
- 형상통제는 형상 항목의 형상 관리를 위해 형상통제위원회(CCB)를 구성하며, 소프트웨어 변경의 요구, 평가, 승인이 이루어진다.

### 개발 도구의 분류
#### 1. 빌드 도구
- 작성한 코드의 빌드 및 배포를 수행하는 도구
- 각각의 구성요소와 모듈에 대한 의존성 관리를 지원

#### 2. 구현 도구
- 코드의 작성과 디버깅, 수정 등과 같은 작업과 구현소프트웨어가 어떤 프로그래밍 언어로 개발되는지 선택
- 프로그램을 개발할 때 가장 많이 사용되는 도구

#### 3. 테스트 도구
- 코드의 기능  검증과 전체의 품질을 높이기 위해 사용하는 도구
- 코드의 테스트, 테스트에 대한 계획, 수행 및 분석 등의 작업 기능

#### 4. 형상 관리 도구
- 개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구
- 프로젝트 진행 시 필수로 포함되는 도구

### 서버의 종류
#### 1. 웹 서버
- HTTP를 이용한 요청/응답을 처리
- 웹 상의 정적 콘텐츠(CSS, Javascript, Image)를 처리
- Apache 웹 서버, IIS 웹 서버, Google Web Server 등이 존재

#### 2. 웹 애플리케이션 서버
- 동적 콘텐츠(Servlet, JSP)를 처리하기 위해 사용
- Tomcat, Weblogic 등이 존재

#### 3. 데이터베이스 서버
- 데이터의 수집, 저장을 위한 용도로 사용
- MySQL, Oracle, MS-SQL 등이 존재

#### 4. 파일 서버
- 물리 저장장치를 활용한 서버
- 대용량 HDD, SSD 등의 장치가 존재

### 클라이언트 하드웨어 개발환경
#### 1. 클라이언트 프로그램
- 설치를 통해 사용자와 커뮤니케이션하는 프로그램
- Visual Basic, C#, Delphi 등으로 개발되어 사용

#### 2. 웹 브라우저
- 웹 서비스 형태로 서버에서 웹 애플리케이션 응답 시 브라우저를 통해 사용자와 커뮤니케이션함
- 일반적인 형태의 웹 사이트가 해당

#### 3. 모바일 앱
- 모바일 디바이스에 설치되어 활용되는 애플리케이션
- App Store, Android Market 등을 통해 다운로드 가능

#### 4. 모바일 웹
- 웹 브라우저와 동일한 형태로 모바일상 웹 브라우저를 통해 서비스 제공
- 모바일에 최적화되어 제공되는 웹사이트가 해당


## 2. 공통 모듈 구현
### 모듈
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 독립됨을 의미함
- 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로 이루어진다.
- 모듈간 **결합도는 낮게, 응집도는 강하게** 만드는 것이 좋음

#### 1. 결합도
- 모듈 내부가 아닌 외부의 모듈과의 연관도, 모듈 간의 상호의존성. 낮을수록 좋음

#### 2. 응집도
- 모듈의 독립성을 나타내는 개념. 높을수록 좋음

### 응집도 유형
#### 1. 우연적 응집도
- 모듈 내부의 각 구성요소들이 연관이 없을 경우

#### 2. 논리적 응집도
- 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우

#### 3. 시간적 응집도
- 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우

#### 4. 절차적 응집도
- 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우

#### 5. 통신적 응집도
- 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우

#### 6. 순차적 응집도
- 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우

#### 7. 기능적 응집도
- 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

위의 7가지 응집도는 아래로 내려갈수록 강해짐(좋아짐)

응집도 : 우논시절 통순기

### 결합도 유형
#### 1. 내용 결합도
- 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우

#### 2. 공통 결합도
- 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경ㅇ

#### 3. 외부 결합도
- 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우

#### 4. 제어 결합도
- 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우

#### 5. 스탬프 결합도
- 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우

#### 6. 자료 결합도
- 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우

위의 7가지 결합도는 아래로 내려갈수록 낮아짐(좋아짐)

결합도 : 내공 외제 스자

- 팬 인(Fan in) : 어떤 모듈을 제어하는 모듈의 수
- 팬 아웃(Fan Out) : 어떤 모듈에 의해 제어되는 모듈의 수
## 3. 서버 프로그램 구현
### 데이터베이스 객체 종류
#### 1. DAO(Data Access Object)
- 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체로 세부내용 노출 없이 데이터 조작

#### 2. DTO(Data Transfer Object)
- 프로세스 사이에서 데이터를 전송하는 객체로 데이터 저장/회수 외에 다른 기능이 없음
- 간단한 엔티티를 의미하는 작은 객체 기반 클래스

#### 3. VO(Value Object)
- DTO와 달리 고정 클래스를 가짐


## 4. 배치 프로그램 구현
### 배치 프로그램
- 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법
- 대량건의 데이터를 특정 시간에 일괄적으로 처리하는 것이 핵심임

# 9. 소프트웨어 개발 보안 구축
## 1. 소프트웨어 개발 보안 설계
### 소프트웨어 개발 보안의 3대 요소
#### 1. 기밀성(Confidentiality)
- 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성

#### 2. 무결성(Integrity)
- 정당한 방법을 따르지 않고서는 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성

#### 3. 가용성(Availability)
- 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속해서 사용할 수 있도록 보장하는 특성

### 소프트웨어 개발 보안을 위한 공격기법 - DoS 공격
- 시스템을 악의적으로 공격해서 해당 시스템이 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
- 특정 서버에 **수많은 접속 시도**를 만들어 다른 이용자가 정상적으로 서비스 이용을 하지 못하게 하거나, 서버의 TCP 연결을 소진시키는 등의 공격

DoS 공격에는 아래와 같은 항목이 존재함

#### 1. SYN Flooding
- TCP 프로토콜의 구조적인 문제를 이용한 공격
- 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
- 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 됨으로 서버는 자원 할당을 해지하지 않고 자원만 소비하여 고갈됨

#### 2. UDP Flooding
- 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지를 생성하게 하여 지속해서 자원을 고갈시키게 하는 공격
- ICMP 패킷은 변조되어 공격자에게 전달되지 않아 대기함

#### 3. Smurfing(스머프/스머핑)
- 출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킹을 직접 브로드캐스팅하여 마비시키는 공격
- 바운스 사이트라고 불리는 제 3 사이트를 이용하여 공격

#### 4. PoD(Ping of Death, 죽음의 핑)
- ICMP 패킷(Ping)을 정상적인 크기보다 아주 크게 만들어 전송하면 다수의 IP 단편화가 발생하고, 수신 측에서는 단편화된 패킷을 처리(재조합)하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 하는 공격기법

#### 5. Land Attack(랜드 어택)
- 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄으로 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법

#### 6. Tear Drop(티어 드롭)
- IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신시스템이 문제를 발생하도록 만드는 DoS 공격
- 공격자는 IP Fragment Offset값을 서로 중첩되도록 조작하여 전송하고, 이를 수신한 시스템이 재조합하는 과정에서 오류가 발생. 시스템의 기능을 마비시키기는 공격 방식

#### 7. Bonk/Boink(봉크/보잉크)
- 프로토콜의 오류 제어를 이용한 공격기법으로, 시스템의 패킷 재전송과 재조립이 과부하를 유발한다.
- Bonk : 같은 시퀀스 번호를 계속 보냄 / Boink : 일정한 간격으로 시퀀스 번호에 빈 공간을 생성함

### 소프트웨어 개발 보안을 위한 공격기법 - DDoS 공격
- DoS의 또다른 형태. 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로 특정 사이트를 공격하는 기법
- 해커들이 취약한 인터넷 시스템에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격으로 공격으로 개시한다.
- 공격의 종류에는 DoS를 포함하여 서비스 마비 공격과 대역폭 소진 공격으로 나눈다.

### DRDoS 공격
- 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버를 요청 정보를 전송. 공격 대상자는 반사 서버로부터 다량의 응답을 받아 서비스 거부가 되는 공격

### 네트워크 공격의 종류
#### 1. Sniffing(스니핑)
- 공격대상에세 직접 공격을 하지 않고 데이터만 몰래 들여다보는 수동적 공격 기법

#### 2. Scanner, Sniffer(네트워크 스캐너, 스니퍼)
- 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격 도구

#### 3. Password Cracking(패스워드 크래킹)
- 사전 크래킹(가능성 단어 검색) 공격, 무차별 크래킹 공격, 패스워드 하이브리드 공격(사전+무차별), 레인보우 테이블(패스워드별 해시값 테이블 생성) 공격 활용

#### 4. IP Spoofing(IP 스푸핑)
- 침입자가 인증된 컴퓨터 시스템인 것처럼 속여서 타깃 시스템의 정보를 빼내기 위해 본인의 패킷 헤더를 인증된 호스트의 IP 어드레스로 위조하여 타깃에 전송하는 공격기법

#### 5. ARP Spoofing(ARP 스푸핑)
- 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Relay를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경. 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격기법

#### 6. ICMP Redirect 공격
- 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라 알림으로 패킷의 흐름을 바꾸는 공격기법
- ICMP Redirect 메시지를 공격자가 원하는 형태로 만들어서 특정 목적지로 가는 패킷을 공격자가 스니핑하는 공격기법

#### 7. Trojan Horses(트로이 목마)
- 악성 루틴이 숨어 있는 프로그램. 겉보기에 정상 프로그램 같지만, 실행하면 악성 코드를 실행하는 프로그램

### Buffer Overflow Attack(버퍼 오버플로우 공격)
- 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 이로 인해 프로세스의 흐름을 변경시켜 악성 코드를 실행시키는 공격기법
- 스택 버퍼 오버플로우 공격과 힙 버퍼 오버플로우 공격이 있다.

### Backdoor(백도어)
- 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법
- 허가받지 않고 시스템에 접속하는 권리를 얻기에 은밀하게 작동함

### 이외 보안 관련 용어
#### 1. Spear Phishing(스피어 피싱)
- 사회 공학의 한 기법. 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도하여 사용자의 개인 정보를 탈취하는 공격기법

#### 2. Smishing(스미싱)
- SMS과 피싱의 합성어
- 문자메시지를 이용하여 신뢰할 수 있는 사람/기업이 보낸 것 처럼 가장하여 개인 비밀번호를 요구하거나, 소액 결제를 유도하는 피싱 공격

#### 3. Qshing(큐싱)
- QR code와 피싱의 합성어
- 스마트폰을 이용하여 인증 등이 필요한 것처럼 가장하여 QR 코드를 통해 악성 앱을 내려받로록 유도하는 피싱 공격

#### 4. Botnet(봇넷)
- 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태

#### 5. Advanced Persistant Threat(APT 공격)
- 특정 타깃을 목표로 하여 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격기법
- 특수목적의 조직이 하나의 표적에 대해 다양한 IT 기술을 이용하여, 지속적으로 정보를 수집하고 취약점을 분석하여 피해를 주는 공격기법

#### 6. Supply Chain Attack(공급망 공격)
- 소프트웨어 개발사 네트워크에 침투하여 소스 코드 수정 등을 통해 악의적인 코드를 삽입. 배포 서버에 접근하여 악의적인 파일로 변경하는 방식을 통해 사용자에게 감염되도록 하는 공격기법

#### 7. Zero Day Attack(제로 데이 공격)
- 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격기법
- 공격의 신속성을 의미하여 대응책이 공표되기도 전에 공격이 이루어지기에 대처 방법이 없음

#### 8. Worm(웜)
- 스스로를 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 컴퓨터 프로그램
- 컴퓨터 바이러스와 비슷하지만, 바이러스가 다른 실행 프로그램에 기생하여 실행되는 데 반해 웜은 독자적으로 실행되며 다른 실행 프로그램이 필요하지 않다는 특징을 가짐

#### 9. Malicious Bot(악성 봇)
- 스스로 실행되지 못하고, 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램/코드
- 취약점, 백도어 등을 이용하여 전파되며, DDoS에 악용됨

#### 10. Cyber Kill Chain(사이버 킬 체인)
- 록히드 마틴의 사이버 킬체인을 공격형 방위 시스템으로 지능적, 지속적 사이버 공격에 대해 7단계 프로세스별 공격분석 및 대응을 체계화한 APT 공격 방어 분석 모델

#### 11. Ransomware(랜섬웨어)
- 감염된 시스템 파일을 암호화하여 복호화할 수 없도록 하고, 피해자로 하여금 암호화된 파일을 인질처럼 잡고 몸값을 요구하는 악성 소프트웨어

#### 12. Evil Twin Attack(이블 트윈 공격)
- 무선 Wifi 피싱 기법으로 공격자는 합법적인 Wifi 제공자처럼 행세하며 노트북이나 휴대 전화로 핫스팟에 연결한 무선 사용자들의 정보를 탈취하는 무선 네트워크 공격기법

#### 13. Obfuscation(난독화)
- 코드의 가독성을 낮춰 역공학에 대한 대비를 하기 위해서 프로그램 코드의 일부 또는 전체를 변경하는 기법
- 난독화를 적용하는 범위에 따라 소스 코드 난독화와 바이너리 난독화로 나눔

#### 14. Tripwire
- 크래커가 침입하여 시스템에 백도어를 만들어놓거나 설정 파일을 변경해 놓았을 때 이러한 사실을 알 수 있게 분석하는 도구
- 시스템 내의 지정한 중요한 디렉토리와 파일에 대한 데이터베이스를 생성한 후에 Tripwire를 실행할 때 새로 생성된 데이터베이스와 비교하여 그 차이점을 체크함으로 시스템 관리자가 시스템 내에서 어떤 변화가 있는지 감지할 수 있게 해주는 도구

#### 15. Ping
- 인터넷으로 접속하려는 원격 호스트가 정상적으로 운영되고 있는지를 확인하는 진단 목적으로 사용하는 명령어

#### 16. Tcpdump
- 네트워크 인터페이스를 거치는 패킷의 내용을 출력해주는 프로그램
- 스니핑 도구의 일종으로 자신의 컴퓨터로 들어오는 모든 패킷의 내용을 도청할 수 있으며, 공격자에 대한 추적 및 공격 유형 분석을 위한 패킷 분석 시 활용할 수 있는 도구

#### 17. SQL Injection
- 응용 프로그램의 보안 취약점을 이용해 악의적인 SQL 구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격기법


### 서버 접근 통제 유형
#### 1. 임의적 접근 통제(DAC; Discretionary Access Control)
- 시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법
- DAC에서 사용자는 자원과 관련된 ACL(Access Control List)이 수정됨으로 자원에 대한 권한을 부여받는다.

#### 2. 강제적 접근 통제(MAC; Mandatory Access Control)
- 시스템 정보의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법
- 관리자만이 시스템 자원에 대한 권한을 할당할 수 있음

#### 3. 역할기반 접근 통제(RBAC; Role Based Access Control)
- 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법
- RBAC에서 자원에 대한 접근은 사용자에게 할당된 역할에 기반함
- 관리자는 사용자에게 특정한 권리와 권한이 정의된 역할을 할당함


암호화 방식에는 **양방향**과 **단방향**이 있다.
- **단방향**에는 **HASH 함수**가 존재함
- **양방향**에는 **개인키(대칭)**와 **공개키**가 존재함
  - **개인키**에는 **Stream 방식**(같은 키 길이를 연속적으로 생성)과 **Block 방식**(평문을 일정한 Block으로 나눔)이 존재
  - Stream 방식에는 RC4, Block 방식에는 DES, AES, SEED 등이 존재


### IPSec
- IP 계층에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용한 IP  보안 프로토콜

## 2. 소프트웨어 개발 보안 구현

### 입력 데이터 검증 및 표현 취약점
#### 1. XSS(Cross Site Script)
- 검증되지 않은 외부 입력 데이터가 포함된 웹페이지가 전송되는 경우, 사용자가 해당 웹페이지를 열람함으로 웹페이지에 포함된 부적절한 스크립트가 실행되는 공격

#### 2. CSRF(Cross Site Request Forgery, 사이트 간 요청 위조)
- 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격

#### 3. SQL Injection(SQL 삽입)
- 응용 프로그램의 보안 취약점을 이용해 악의적 SQL 구문을 삽입, 실행시켜 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격기법

### 비즈니스 연속성 계획 관련 주요 용어
#### 1. BIA(Business Impact Analysis)
- 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석

#### 2. RTO(Recovery Time Objective)
- 업무중단 시점부터 업무가 복구되어 다시 가동될 때까지의 시간
- 재해 시 복구 목표 시간의 선정

#### 3. RPO(Recovery Point Objective)
- 업무중단 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점
- 재해 시 복구 목표 지점의 선정

#### 4. DRP(Disaster Recovery Plan)
- 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획

#### 5. DRS(Disaster Recovery System)
- 재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적, 물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터

### 보안 공격 관련 중요 용어
#### 1. Side Channel Attack(부 채널 공격)
- 암호화 알고리즘의 실행 시기의 전력 소비, 전자기파 방사 등의 물리적 특성을 측정하여 암호 키 등 내부 비밀 정보를 부 채널에서 획득하는 공격 기법

#### 2. Drive By Download(드라이브 바이 다운로드)
- 악의적인 해커가 불특정 웹 서버와 웹 페이지에 악성 스크립트를 설치하고, 불특정 사용자 접속 시 사용자 동의 없이 실행되어 의도된 서버로 연결하여 감염시키는 공격기법

#### 3. Watering Hole(워터링 홀)
- 특정인에 대한 표적 공격을 목적으로 특정인이 잘 방문하는 웹 사이트에 악성코드를 심거나 악성코드를 배포하는 URL로 자동으로 유인하여 감염시키는 공격기법

#### 4. SCAM(스캠 공격)
- 기업 이메일 계정을 도용하여 무역 거래 대금을 가로채는 사이버 범죄

#### 5. HeartBlood(하트블러드)
- OpenSSL 암호화 라이브러리의 하트비트라는 확장 모듈에서 클라이언트 요청 메시지를 처리할 때 데이터 길이에 대한 검증을 수행하지 않는 취약점을 이용하여 시스템 메모리에 저장된 64KB 크기의 데이터를 외부에서 아무런 제한 없이 탈취할 수 있도록 하는 취약점

#### 6. Crimeware(크라임웨어)
- 중요한 금융정보 또는 인증정보를 탈취하거나 유출을 유도하여 금전적인 이익 등의 범죄행위를 목적으로 하는 악성코드

#### 7. IoT-SSDP(Simple Servie Discovery Protocol. 프로토콜 취약점)
- 단순 서비스 검색 프로토콜(SSDP)의 특성을 활용하여 IoT Device를 좀비 PC로 이용한 분산 서비스 거부 공격

#### 8. WindTalker(윈드토커)
- 와이파이/핫스팟 연결 디바이스의 터치스크린, 키보드 타이핑 등의 CSI(Channel State Information) 무선신호패턴을 스니핑하여 해킹하는 기술

#### 9. Tor Network(토르 네트워크)
- 네트워크 경로를 알 수 없도록 암호화 기법을 사용하여 데이터를 전송하며, 익명으로 인터넷을 사용할 수 있는 가상 네트워크

#### 10. Meltdown(멜트다운)
- 인텔 x86 아키텍처에서 CPU  파이프라인의 비순차 명령 실행 시 발생하는 버그를 악용해서 커널 사용자 영역의 우회를 통해 시스템 메모리에 접근하여 내용을 확인할 수 있는 취약점

#### 11. Spectre(스펙터)
- 실패한 분기 예측으로 인해 메모리 데이터가 관찰될 수 있는 취약점을 이용하여 사용자 프로그램이 다른 사용자 프로그램의 메모리 영역을 훔쳐보고 정보를 탈취할 수 있는 취약점
- 분기 예측이 적용된 모든 현대 마이크로프로세서에 영향을 주는 하드웨어 보안취약점

#### 12. MITM 공격(Man in the Middle)
- 네트워크 통신을 조작하여 통신 내용을 도청 및 조작하는 공격기법
- 통신을 연결하는 두 사람 사이 중간에 침입하여 두 사람의 정보를 탈취하는 중간자 공격

#### 13. DNS Spoofing(DNS 스푸핑 공격)
- 공격 대상에게 전달되는 DNS 응답을 조작하거나 DNS 서버의 캐시 정보를 조작하여 희생자가 의도하지 않은 주소로 접속하게 만드는 공격기법
- DNS Cache Poisoning 이라고도 불림

#### 14. Port Scanning(포트 스캐닝)
- 공격자가 침입 전 대상 호스트에 어떤 포트가 활성화되어 있는지 확인하는 기법
- 취약점을 분석하기 위한 사전 작업

#### 15. Directory Listing(디렉토리 리스팅 취약점)
- 웹 애플리케이션을 사용하고 있는 서버의 미흡한 설정으로 인해 인덱싱 기능이 활성화되어 있을 경우, 공격자가 강제 브라우징을 통해서 서버 내의 모든 디렉토리 및 파일 목록을 볼 수 있는 취약점

#### 16.  Reverse Shell(리버스 쉘 공격)
- 타깃 서버가 클라이언트(공격자)로 접속해서 클라이언트가 타깃 서버의 쉘을 획득해 공격하는 기법

#### 17. Exploit(익스플로잇)
- 소프트웨어나 하드웨어의 버그 또는 취약점을 이용하여 공격자가 의도한 동작이나 명령을 실행하도록 하는 코드 또는 그러한 행위

#### 18. Stuxnet(스턱스넷 공격)
- 독일 지멘스사의 SCADA 시스템을 공격 목표로 제작된 악성코드로 원자력, 전기, 철강, 반도체, 화학 등 주요 산업 기반 시설의 제어 시스템에 침투해 오작동을 일으키는 악성코드 공격기법

#### 19. Credential Stuffing(크레덴셜 스터핑)
- 사용자 계정을 탈취해서 공격하는 유형 중 하나
- 다른 곳에서 유출된 아이디와 비밀번호 등의 로그인 정보를 다른 웹 사이트나 앱에 무작위로 대입해 로그인이 이루어지면 타인의 정보를 유출시키는 기법

# 10. 애플리케이션 테스트 관리
## 1. 애플리케이션 테스트 케이스 설계
소프트웨어 테스트는 오류 발견 관점, 오류 예방 관점, 품질 향상 관점에서 필요하다.
### 소프트웨어 테스트 원리
#### 1. 살충제 패러독스
- 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
- 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근 필요

#### 2. 결함 집중(파레토 법칙)
- 적은 수의 모듈에서 대다수의 결함이 발견됨
- 소프트웨어 테스트에서의 오류의 80%는 전체 모듈의 20% 내에서 발견됨

#### 3. 오류-부재의 궤변
- 요구 사항을 충족시켜주지 못한다면, 결함이 없다 해도 품질이 높다 할 수 없다.
### 프로그램 실행 여부에 따른 테스트 분류
#### 1. 정적 테스트
- 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트
- 리뷰, 정적 분석이 해당
  - 리뷰의 유형에는 관리 리뷰, 기술 리뷰, 인스펙션, 워크스루, 감사 등이 있음

#### 2. 동적 테스트
- 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트\
- 화이트박스 테스트, 블랙박스 테스트, 경험기반 테스트가 이에 해당

### 2. 테스트 기법에 따른 테스트 분류
#### 1. 화이트박스 테스트
- 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
- 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 테스트
- 소스 코드의 모든 문장을 한 번 이상 수행함으로 진행됨
- 유형에는 구문 커버리지, 결정 커버리지, 조건 커버리지, 조건/결정 커버리지 등이 존재함

#### 2. 블랙박스 테스트
- 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트이다.
- 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점을 맞춰 테스트가 이루어진다.
- 유형에는 동등분할 테스트, 경곗값 분석 테스트, 결정 테이블 테스트 등이 존재한다.
  - **동등분할 테스트** : 입력 데이터의 영역을 유사한 도메인별 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스로 테스트하는 방식
  - **경곗값 분석 테스트** : 경곗값 부분에서 오류 발생 확률이 높기에 이를 포함하여 테스트 케이스를 설계하는 방식
- 동작 위주의 테스트를 진행하기에 내부 구조나 작동 원리를 알지 못해도 가능함

### 테스트 오라클
- 테스트 결과가 참인지 거짓인지를 판단하기 위해 사전에 정의된 참값을 입력하여 비교하는 기법

#### 1. 참(True) 오라클
- 모든 입력값에 대하여 기대하는 결과를 생성함으로 발생된 오류를 모두 검출할 수 있는 오라클

#### 2. 샘플링(Sampling) 오라클
- 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클

#### 3. 휴리스틱(Heuristic) 오라클
- 샘플링 오라클을 개선한 형태. 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클

#### 4. 일관성 검사(Consistent) 오라클
- 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클

### 테스트 레벨
- 함께 편성되고 관리되는 테스트 활동의 그룹
#### 1. 단위 테스트
- 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계
#### 2. 통합 테스트
- 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계
#### 3. 시스템 테스트
- 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트단계
#### 4. 인수 테스트
- 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계


## 2. 애플리케이션 통합 테스트
### 단위 테스트
- 개별적인 모듈(또는 컴포넌트)을 테스트한다.
- 구현 단계에서 각 모듈을 구현 후 수행한다.
- 개별적인 모듈에 대해 컴포넌트 테스트를 수행하려면 모듈을 단독으로 실행할 수 있는 테스트 베드(Test Bed)라는 환경이 필요하다.

### 테스트 자동화 도구
- 테스트 도구를 활용하여 반복적인 테스트 작업을 스크립트 형태로 구현함으로 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트를 수행할 수 있는 방법
- 장점 : 테스트 데이터 재입력 작업의 자동화, 객관적 평가 기준 제공
- 단점 : 도구 사용 방법 학습 필요, 도구를 프로세스 단계별로 적용하기 위한 시간이 필요함, 추가 투가 비용 발생

### 테스트 자동화 도구 유형
#### 1. 정적 분석 도구(Static Analysis Tools)
- 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
- 대부분의 경우 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위하여 사용
- 테스트를 수행하는 사람이 작성된 소스 코드에 대한 이해를 바탕으로 도구를 이용해서 분석하는 것

#### 2. 테스트 실행 도구(Test Execution Tools)
- 테스트를 위해 작성된 스크립트를 실행하고, 작성된 스크립트를 각 스크립트마다 특정 데이터와 테스트 수행 방법을 포함함
- 데이터 주도 접근 방식과 키워드 주도 접근 방식이 존재함

#### 3. 성능 테스트 두구(Performance Test Tools)
- 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로 성능 목표를 달성하였는지를 확인하는 도구

#### 4. 테스트 통제 도구(Test Control Tools)
- 테스트 계획 및 관리를 위한 테스트 관리 도구, 테스트 수행에 필요한 데이터와 도구를 관리하는 형상 관리 도구, 테스트에서 발생한 결함에 대해 관리하거나 협업을 지원하기 위한 결함 추적/관리 도구 등이 존재

### 테스트 하네스(Test Harness)
- 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하여, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성한다.

#### 테스트 하네스 구성요소
1. **Test Driver(테스트 드라이버)** : 테스트 대상 하위 모듈 호출, 파라미터 전달, 모듈 테스트 수행 후의 결과 도출 등 **상향식 테스트**에 필요
2. **Test Stub(테스트 스텁)** : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구. **하향식 테스트**에 필요
3. Test Suites(테스트 슈트) : 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
4. Test Case(테스트 케이스) : 입력값, 실행조건, 기대결과 등의 집합
5. Test Script(테스트 스크립트) : 자동화된 테스트 실행 절차에 대한 명세
6. Mock Object(목 오브젝트) : 사용자의 행위를 조건부로 사전에 입력하면, 상황에 예정된 행위를 수행하는 객체

### 테스트 커버리지
- 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준
#### 테스트 커버리지 유형
1. 기능 기반 커버리지 : 앱의 전체 기능을 모수로 설정, 실제 테스트가 수행된 기능의 수를 측정하는 방법
2. 라인 커버리지 : 전체 소스 코드 라인 수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인 수 측정
3. 코드 커버리지 : 소프트웨어 테스트 충분성 지표 중 하나. 소스 코드 구문, 조건, 결정 등의 구조 코드가 얼마나 테스트되었는지를 측정하는 방법. 일반적으로 **테스트 커버리지라 하면 코드 커버리지**를 말함


## 3. 애플리케이션 성능 개선
### 애플리케이션 성능 측정 지표
#### 1. Throughput(처리량)
- 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수
- 웹 애플리케이션의 경우 시간당 페이지 수로 표현

#### 2. Response Time(응답 시간)
- 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간
- 애플리케이션의 경우 메뉴 클릭 시 해당 메뉴가 나타나기까지 걸리는 시간

#### 3. Turnaround Time(반환 시간)
- 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션 처리 후, 그 결과의 출력이 완료될 때까지 걸리는 시간

#### 4. Resource Usage(자원 사용률)
- 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

### Bad Code(베드 코드)의 사례
#### 1. Alien Code(외계인 코드)
- 아주 오래되거나 참고문서/개발자가 없어 유지보수 작업이 아주 어려운 코드

#### 2. Spaghetti Code(스파게티 코드)
- 컴퓨터 프로그램의 소스 코드가 복잡하게 얽힌 모습을 스파게티 변발에 비유한 표현
- 작동은 정상적으로 하지만, 사람이 코드를 읽으면서 그 코드의 작동을 파악하기는 어려운 코드임

클린 코드의 작성 원칙으로는 가독성, 단순성, 의존성 최소, 중복성 제거, 추상화가 있음

### Refactoring(리팩토링)
- 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법

리팩토링의 목적에는 **유지보수성 향상, 유연한 시스템, 생산성 향상, 품질향상**이 있다.

# 11. 응용 SW 기초 기술 활용
## 1. 운영체제의 특징
### 운영체제
- 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어
- 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리/운영함으로 사용자에게 편의성을 제공한다.
- 운영체제는 크게 인터페이스(쉘)+커널의 구조이다.
- 운영체제의 핵심적인 기능들이 커널에 모여있다면, 인터페이스는 이러한 커널을 사용자가 보다 편리하게 사용할 수 있게 해준다.

### 유닉스(Unix) 계열 운영체제
- 교육 및 연구기관에서 사용되는 범용 다중 사용자 방식의 시분할 운영체제임
- 처음부터 다양한 시스템에 서로 이식할 수 있고, 멀티 태스킹과 다중 사용자를 지원하도록 설계되었다.
- 대화식 운영체제 기능, 계층적 트리 구조 파일 시스템을 제공한다는 특징을 가진다.

리눅스와 유닉스 명령어는 **쉘**에서 입력할 수 있다.

### 프로세스 상태
- 하나의 프로세스는 여러 가지 이벤트에 의해 일련의 서로 구분되는 상태 변화를 겪는다.
- 생성 상태, 준비 상태, 실행 상태, 대기 상태, 완료 상태를 가질 수 있다
#### 1. 생성 상태(Create)
- 사용자에 의해 프로세스가 생성된 상태

#### 2. 준비 상태(Ready)
- CPU를 할당받을 수 있는 상태
- 준비 리스트(Ready List) : 각각 우선순위를 부여하여 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당받는다.

#### 3. 실행 상태(Running)
- 프로세스가 CPU를 할당받아 동작중인 상태

#### 4. 대기 상태(Waiting)
- 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태
- 대기 리스트에는 우선순위가 존재하지 않음

#### 5. 완료 상태(Complete)
- 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태

### 프로세스 상태 전이
#### 1. Dispatch(디스패치)
- 준비 상태에 있는 여러 프로세스(Ready List) 중 실행될 프로세스를 선정하여(Scheduling) CPU를 할당한느 작업
- 여기서 문맥 교환이 발생한다.

#### 2. Timer Run Out(타이머 런 아웃)=할당 시간 초과
- CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비 상태로 전이됨
- 프로세스는 실행 상태에서 준비 상태로 전이
- 타임 슬라이스 말료, 선점 시 타임아웃이 발생함

#### 3. Block(블록)=입출력 발생
- 실행 상태에 있는 프로세스가 지정된 할당시간을 초과하기 전에 입출력이나 기타 사건이 발생하면 CPU를 스스로 반남하고 입출력이 완료될 때까지 대기 상태로 전이됨
- 프로세스는 실행 상태에서 대기 상태로 전이
- 즉시 실행 불가능한 시스템 콜, I/O 작업 시작, 프로세스간 통신 시 Block 발생

#### 4. Wake-up(웨이크 업)=깨움
- 어느 순간에 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이됨
- 프로세스는 대기 상태에서 준비 상태로 전이

### 클라우드 컴퓨팅
- 인터넷을 통해 가상화된 컴퓨터 시스템 리소스를 제공하고, 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술
- 구성 가능한 컴퓨팅 자원에 대해 어디서나 접근할 수 있다.

### 클라우드 컴퓨팅 유형
#### 1. IaaS(인프라형 서비스, Infrastructure as a Service)
- 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스
- 컴퓨팅 자원에 운영체제나 애플리케이션 등의  소프트웨어 탑재 및 실행
- 하위의 클라우드 인프라를 제어하거나 관리하지 않지만 스토리지, 애플리케이션에 대해서는 제어권을 가짐

#### 2. PaaS(플랫폼형 서비스, Platform as a Service)
- 인프라를 생성, 관리하는 복잡함 없이 애플리케이션을 개발, 실행, 관리할 수 있게 하는 플랫폼을 제공하는 서비스
- SaaS 개념을 개발 플랫폼에 확장한 방식

#### 3. SaaS(소프트웨어형 서비스, Software as a Service)
-  소프트웨어 및 관련 데이터는 중앙에 호스팅되고 사용자는 웹 브라우저 등의 클라이언트를 통해 접속하여 소프트웨어를 서비스 형태로 이용하는 서비스
-  주문형 소프트웨어라고도 함

#### 부록 : chmod 명령어 사용
- 읽기/쓰기/실행 권한 부여의 가중치는 각각 4/2/1이다.
- 권한 부여 순서는 사용자/그룹/기타에 해당된다.
- 사용자에게 읽기/쓰기/실행 권한을 부여하고 싶을 경우 chmod 4+2+1=7을 선언하면 됨
## 2. 네트워크 기초 활용하기
### OSI 7계층
- 국제 표준화 기구인 ISO(International Standardization Organization)에서 개발한 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 개방형 시스템 상호 연결 모델

#### 1. 응용 계층(Application)
- 사용자와 네트워크 간 응용서비스 연결
- 프로토콜에는 HTTP, FTP / 전송단위는 데이터

#### 2. 표현 계층(Presentation)
- 데이터 형식 설정, 부호교환, 암/복호화
- 프로토콜에는 JPEG, MPEG / 전송단위는 데이터

#### 3. 세션 계층(Session)
- 송수신 간의 논리적인 연결, 연결 접속, 동기제어
- 프로토콜에는 RPC, NetBIOS / 전송단위는 데이터

#### 4. 전송 계층(Transport)
- 송수신 프로세스 간 연결
- 신뢰성 있는 통신 보장, 데이터 분할/재조립, 흐름제어, 오류제어
- 프로토콜에는 TCP, UDP / 전송단위는 세그먼트

#### 5. 네트워크 계층(Network)
- 단말기 간 데이터 전송을 위한 최적화 경로 제공
- 프로토콜에는 IP, CMP / 전송단위는 패킷

#### 6. 데이터링크 계층(Data Link)
- **인접 시스템 간** 데이터 전송, 전송 오류 제어, 동기화, 회선제어
- 프로토콜로는 HDLC, PPP / 전송단위는 프레임

#### 7. 물리 계층(Physical)
- 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
- 프로토콜로는 RS-232C / 전송단위는 비트

### 프로토콜
- 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약
- 프로토콜의 3요소에는 구문(Syntax), 의미(Semantic), 타이밍(Timing)이 존재함
- 심리학자 톰 마릴의 '기술적 은어'를 뜻하는 프로토콜에서 유래됨

### IPv4
- 인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층의 프로토콜
- 주소체계는 10진수로 총 12자리이며, 네 부분으로 나뉜다.
- 32비트로 구성되어 있으며, 인터넷 사용자의 증가로 128비트를 가지는 IPv6가 증가하게 되었다.

### IPv6
- 인터넷 프로토콜 스택 중 네트워크 계층의 프로토콜로서 버전 6 인터넷 프로토콜로 지정된 차세대 인터넷 프로토콜임
- 특징으로 IP 주소의 확장, 이동성, 인증 및 보안 기능, 개선된 QoS, 단순 헤더 적용, 실시간 패킷 추적 기능이 있음
- 기존 IPv4 헤더에 비해 출발지 주소, 목적지 주소 길이로 인하여 커졌고, IPv4의 불필요한 필드를 제거함으로 헤더가 단순해졌다. (커졌지만 단순해짐)

### IPv4에서 v6로 변환 방법
1. **듀얼 스택** : 두 가지의 프로토콜이 모두 탑재되어 있어 통신 상대방에 따라 해당 IP 스택을 사용함
2. **터널링** : 인접한 IPv4 망을 거칠 때 해당 망에 터널을 만들고 IPv4에서 사용하는 프로토콜로 캡슐화하여 전송
3. **주소변환** : IPv4 와 IPv6망 사이에 주소변환기(게이트웨이)를 설치하여 서로 다른 네트워크 상의 패킷을 변환

### 데이터 전송 프로토콜의 종류
1. **멀티캐스트** : 인터넷에서 같은 내용의 데이터를 여러 명의 특정한 그룹의 수신자들에게 동시 전송
2. **유니캐스트** : 고유 주소로 식변된 하나의 네트워크 목적지에 1:1로 메시지 전송
3. **애니캐스트** : 단일 송신자로부터의 데이터그램을 수신자 그룹 안에서 가장 가까운 노드로 연결

### 라우팅 프로토콜의 종류(네트워크 계층)

#### RIP(Routing Information Protocol)
- AS(Autonomous System; 자치 시스템; 자율 시스템) 내에서 사용하는 거리 벡터 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜
- 벨만 포드 알고리즘, 15홉 제한 등을 특징으로 가진다.

#### OSPF(Open Shortest Path First)
- 규모가 크고 복잡한 TCP/IP 환경에서의 RIP 단점 보완을 위해 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜
- 다익스트라 알고리즘, 라우팅 메트링 지정 등을 특징으로 가진다.

#### BGP(Border Gateway Protocol)
- AS 상호간에 경로 정보를 교환하기 위한 라우팅 프로토콜
- ISP 사업자들 상호 간 주로 사용되는 라우팅 프로토콜
- 라우팅 비용이 많이 들고, 라우팅 테이블 크기가 커서 메모리 사용량이 많다.
## 3. 기본 개발환경 구축하기
### 개발환경 인프라 방식
- On-Premise(온 프레미스) : 외부 인터넷망이 차단된 상태에서 인트라넷망만을 이용하여 개발환경을 구축하는 방시 
- Cloud(클라우드) : 클라우드 공급 서비스를 하는 회사의 서비를 임대하여 개발환경을 구축하는 방식
- Hybrid(하이브리드) : 온프레미스와 하이브리드를 결합한 형식

# 12. 제품 소프트웨어 패키징
## 1. 제품 소프트웨어 패키징하기
### 제품 소프트웨어 패키징(Product Software Packaging)
- 개발이 완료된 제품 소프트웨어를 고객에게 전달히기 위한 형태로 포장하는 과정
- 모듈의 개념을 정확하게 파악한 후에 기능 단위로 패키징하는 것이 중요함
### 모듈화
- 모듈을 이용하여 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하도록 하는 모듈 중신의 소프트웨어 설계 기법
- 모듈간 결합도의 최소화하고 모듈 내 요소들 간의 응집도는 최대화하는 것이 중요하다.
- 모듈화 수행시 개발 편의성, 복잡성 감소의 특징을 가진다.

### 릴리즈 노트(Release Note)
- 최종 사용자인 고객에게 개발 과정에서 정리된 제품의 릴리즈 정보를 제공하는 문서
- 현제 시제로 작성되어야 하며, 배포 시부터 신규 소스, 빌드 등 이력을 명확하고 정확하게 제공하여야 한다.
- 특정 소프트웨어의 최근 변경 사항, 개선 사항 및 버그 수정을 간결히 요약한다.

### 릴리즈 노트에 들어갈 항목
- **헤더** : 문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등의 정보
- 개요 : 제품 및 변경에 대한 간략한 전반적 개요
- 목적 : 릴리즈 버전의 새로운 기능목록과 릴리스 노트의 목적에 관한 개요, 버그 수정 및 새로운 기능 기술
- 이슈 요약 : 버그의 간단한 설명 또는 릴리즈 추가 항목 요약
- 재현 항목 : 버그 발견에 따른 재현 단계 기술
- 수정/개선 내용 : 수전/개선의 간단한 설명 기술
- 사용자 영향도 : 버전 변경에 따른 최종 사용자 기준의 기능 및 응용 프로그램상의 영향도 기술
- 소프트웨어 지원 영향도 : 버전 변경에 따른 소프트웨어의 지원 프로세스 및 영향도 기술
- 노트 : 소프트웨어 및 하드웨어 설치 항목, 제품, 문서를 포함한 업그레이드 항목 메모
- 면책 조항 : 회사 및 표준 제품과 관련된 메시지, 프리웨어 및 불법 복제 방지, 중복 등 참조에 대한 고지사항
- 연락 정보 : 사용자 지원 및 문의에 관련한 연락처 정보

### 디지털 저작권 관리-저작권 관리 구성요소
- 콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자
- 콘텐츠 분배자(Contents Distributor) : 쇼핑몰 등에서 암호화된 콘텐츠 제공
- **패키저(Packager)** : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
- 보안 컨테이너(Security Container) : 원본을 안전하게 유통하기 위한 전자적 보안 장치
- **DRM 컨트롤러(DRM Controller)** : 배포된 콘텐츠의 이용 권한 통제
- **클리어링 하우스(Clearing House)** : 소비자와 유통업자 사이에 발생하는 거래에 대해 디지털 저작권 라이선싱 중개. 모니터링 서비스를 지원하여 디지털 저작물의 이용 내역을 근거로 신뢰할 수 있는 저작권료의 정산 및 분배가 이루어짐


## 2. 제품 소프트웨어 매뉴얼 작성 및 버전 등록
### 백업의 유형
- 전체 백업(Full Backup) : 백업받고자 하는 데이터 전체에 대해 백업하는 방식
- 차등 백업(Differential Backup) : 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식
- 증분 백업(Incremental Backup) : 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업하는 방식